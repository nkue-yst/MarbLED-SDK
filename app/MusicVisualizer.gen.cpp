/********************************************
 ** This file is generated by AppGenerator **
 ********************************************/

#include "MusicVisualizer.gen.hpp"
#include "TLL.h"

#include <chrono>
#include <iostream>
#include <thread>

#define BEAT_OFFSET 200    // 円が動ききるまでの時間（ms）
#define DURATION 10        // 円の大きさが1変わる間隔

MusicVisualizer::MusicVisualizer()
{
    std::cout << "Create MusicVisualizer instance." << std::endl;
}

MusicVisualizer::~MusicVisualizer()
{
    std::cout << "Delete MusicVisualizer instance." << std::endl;
}

void MusicVisualizer::init()
{
    tll::OscHandler::sendMessage("/tll/app/MusicVisualizer/init", "192.168.0.100", 3333);
    tll::clear();
}

void MusicVisualizer::run()
{
    tll::clear();
    tll::drawCircle(this->x, this->y, rad, tll::Palette::White);
}

void MusicVisualizer::terminate()
{
    tll::OscHandler::sendMessage("/tll/app/MusicVisualizer/terminate", "192.168.0.100", 3333);
}

void MusicVisualizer::onTouched(tll::TouchInfo ti)
{
    if (ti.id == 0)
    {
        this->x = ti.x;
        this->y = ti.y;
    }
}

void MusicVisualizer::onMoved(tll::TouchInfo ti)
{
    if (ti.id == 0)
    {
        this->x = ti.x;
        this->y = ti.y;
    }
}

void MusicVisualizer::onReleased(tll::TouchInfo ti)
{

}

void MusicVisualizer::procOscMessage(const osc::ReceivedMessage& msg)
{
    osc::ReceivedMessage::const_iterator arg = msg.ArgumentsBegin();

    if (strcmp(msg.AddressPattern(), "/tll/app/MusicVisualizer/beat_notify") == 0)
    {
        this->beatNotified();
    }
    else if (strcmp(msg.AddressPattern(), "/tll/app/MusicVisualizer/value") == 0)
    {
        this->rad = (arg++)->AsInt32();
    }
}

void MusicVisualizer::beatNotified()
{
    static auto expandCircle = [this](double offset)
    {
        std::this_thread::sleep_for(std::chrono::milliseconds(static_cast<int>(offset)));
        tll::clear();
        tll::drawCircle(this->x, this->y, 6, tll::Palette::White);
        tll::drawCircle(this->x, this->y, 7, tll::Palette::Aqua);
        std::this_thread::sleep_for(std::chrono::milliseconds(DURATION));
        tll::clear();
        tll::drawCircle(this->x, this->y, 7, tll::Palette::White);
        tll::drawCircle(this->x, this->y, 8, tll::Palette::Aqua);
        std::this_thread::sleep_for(std::chrono::milliseconds(DURATION));
        tll::clear();
        tll::drawCircle(this->x, this->y, 8, tll::Palette::White);
        tll::drawCircle(this->x, this->y, 9, tll::Palette::Aqua);
        std::this_thread::sleep_for(std::chrono::milliseconds(DURATION));
        tll::clear();
        tll::drawCircle(this->x, this->y,  9, tll::Palette::White);
        tll::drawCircle(this->x, this->y, 10, tll::Palette::Aqua);
        std::this_thread::sleep_for(std::chrono::milliseconds(DURATION));
        tll::clear();
        tll::drawCircle(this->x, this->y, 10, tll::Palette::White);
        tll::drawCircle(this->x, this->y, 11, tll::Palette::Aqua);
        std::this_thread::sleep_for(std::chrono::milliseconds(DURATION));
        tll::clear();
        tll::drawCircle(this->x, this->y, 11, tll::Palette::White);
        tll::drawCircle(this->x, this->y, 12, tll::Palette::Aqua);
        std::this_thread::sleep_for(std::chrono::milliseconds(DURATION));
        tll::clear();
        tll::drawCircle(this->x, this->y, 12, tll::Palette::White);
        tll::drawCircle(this->x, this->y, 13, tll::Palette::Aqua);
        std::this_thread::sleep_for(std::chrono::milliseconds(DURATION));
        tll::clear();
        tll::drawCircle(this->x, this->y, 13, tll::Palette::White);
        tll::drawCircle(this->x, this->y, 14, tll::Palette::Aqua);
        std::this_thread::sleep_for(std::chrono::milliseconds(DURATION));
        tll::clear();
        tll::drawCircle(this->x, this->y, 14, tll::Palette::White);
        tll::drawCircle(this->x, this->y, 15, tll::Palette::Aqua);
        std::this_thread::sleep_for(std::chrono::milliseconds(DURATION));
    };

    std::chrono::system_clock::time_point notified_tp = std::chrono::system_clock::now();

    double elapse = std::chrono::duration_cast<std::chrono::milliseconds>(notified_tp - this->pre_tp).count();
    double elapse_ave = (this->pre_pre_elapse + this->pre_elapse + elapse) / 3.f;

    double start_offset = elapse_ave - BEAT_OFFSET;

    if (start_offset > 5000)    // 間隔が大きすぎる場合は無効値とする
    {

    }
    else if (start_offset > 0.0)    // 正の数であれば円を動かす
    {
        std::cout << start_offset << "ms後に円を動かす" << std::endl;
        std::thread thread_expandCircle(expandCircle, start_offset);
        thread_expandCircle.detach();
    }
    else    // 間隔が短すぎる場合は無効なビートとする
    {
        return;
    }

    this->pre_pre_tp = this->pre_tp;
    this->pre_tp = notified_tp;

    this->pre_pre_elapse = this->pre_elapse;
    this->pre_elapse = elapse;
}
