/********************************************
 ** This file is generated by AppGenerator **
 ********************************************/

#include "MusicVisualizer.gen.hpp"

#include <iostream>
#include <unistd.h>
#include <thread>
#include <chrono>
#include <vector>

#define BEAT_OFFSET 200    // 円が動ききるまでの時間（ms）
#define DURATION 10        // 円の大きさが変わる間隔

MusicVisualizer* MusicVisualizer::load()
{
    return AppBase::load<MusicVisualizer>();
}

void MusicVisualizer::init()
{
    sendOscMessage("/tll/app/music_visualizer/init");
}

void MusicVisualizer::run()
{
    this->is_running = true;

    while (loop())
    {
        if (!this->is_running)
            break;
    }
}

void MusicVisualizer::terminate()
{
    sendOscMessage("/tll/app/music_visualizer/terminate");
}

void MusicVisualizer::procMessage(const osc::ReceivedMessage& msg)
{
    osc::ReceivedMessage::const_iterator arg = msg.ArgumentsBegin();

    if (strcmp(msg.AddressPattern(), "/tll/app/music_visualizer/beat_notify") == 0)
    {
        this->beatNotified();
    }
    else if (strcmp(msg.AddressPattern(), "/tll/app/music_visualizer/value") == 0)
    {
        clear();
        int32_t rad = (arg++)->AsInt32();
        drawCircle(this->x, this->y, rad, Palette::color("White"));
    }
    else
    {
        std::cout << "未対応のメッセージです." << std::endl;
    }
}

void MusicVisualizer::onTouched(uint32_t x, uint32_t y)
{

}

void MusicVisualizer::onMoved(uint32_t x, uint32_t y)
{

}

void MusicVisualizer::onReleased()
{

}

void MusicVisualizer::beatNotified()
{
    static auto expandCircle = [this](double offset)
    {
        std::this_thread::sleep_for(std::chrono::milliseconds(static_cast<int>(offset)));
        clear();
        drawCircle(this->x, this->y, 6, Palette::color("White"));
        drawCircle(this->x, this->y, 7, Palette::color("Aqua"));
        std::this_thread::sleep_for(std::chrono::milliseconds(DURATION));
        clear();
        drawCircle(this->x, this->y, 7, Palette::color("White"));
        drawCircle(this->x, this->y, 8, Palette::color("Aqua"));
        std::this_thread::sleep_for(std::chrono::milliseconds(DURATION));
        clear();
        drawCircle(this->x, this->y, 8, Palette::color("White"));
        drawCircle(this->x, this->y, 9, Palette::color("Aqua"));
        std::this_thread::sleep_for(std::chrono::milliseconds(DURATION));
        clear();
        drawCircle(this->x, this->y, 9, Palette::color("White"));
        drawCircle(this->x, this->y, 10, Palette::color("Aqua"));
        std::this_thread::sleep_for(std::chrono::milliseconds(DURATION));
        clear();
        drawCircle(this->x, this->y, 10, Palette::color("White"));
        drawCircle(this->x, this->y, 11, Palette::color("Aqua"));
        std::this_thread::sleep_for(std::chrono::milliseconds(DURATION));
        clear();
        drawCircle(this->x, this->y, 11, Palette::color("White"));
        drawCircle(this->x, this->y, 12, Palette::color("Aqua"));
        std::this_thread::sleep_for(std::chrono::milliseconds(DURATION));
        clear();
        drawCircle(this->x, this->y, 12, Palette::color("White"));
        drawCircle(this->x, this->y, 13, Palette::color("Aqua"));
        std::this_thread::sleep_for(std::chrono::milliseconds(DURATION));
        clear();
        drawCircle(this->x, this->y, 13, Palette::color("White"));
        drawCircle(this->x, this->y, 14, Palette::color("Aqua"));
        std::this_thread::sleep_for(std::chrono::milliseconds(DURATION));
        clear();
        drawCircle(this->x, this->y, 14, Palette::color("White"));
        drawCircle(this->x, this->y, 15, Palette::color("Aqua"));
        std::this_thread::sleep_for(std::chrono::milliseconds(DURATION));
    };

    std::chrono::system_clock::time_point notified_tp = std::chrono::system_clock::now();

    double elapse = std::chrono::duration_cast<std::chrono::milliseconds>(notified_tp - this->pre_tp).count();
    double elapse_ave = (this->pre_pre_elapse + this->pre_elapse + elapse) / 3.f;

    double start_offset = elapse_ave - BEAT_OFFSET;

    if (start_offset > 5000)    // 間隔が大きすぎる場合は無効値とする
    {
    }
    else if (start_offset > 0.0)    // 正の数であれば円を動かす
    {
        std::cout << start_offset << "ms後に円を動かす" << std::endl;
        std::thread thread_expandCircle(expandCircle, start_offset);
        thread_expandCircle.detach();
    }
    else    // 間隔が短すぎる場合は無効なビートとする
    {
        return;
    }

    this->pre_pre_tp = this->pre_tp;
    this->pre_tp = notified_tp;

    this->pre_pre_elapse = this->pre_elapse;
    this->pre_elapse = elapse;
}
